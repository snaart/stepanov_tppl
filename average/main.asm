; "global": { Говорит: "Эй, линковщик, вот эту метку (_main) надо сделать видимой
;             снаружи, это точка входа!". Без нее линковщик не найдет, откуда
;             запускать прогу }
; "section .data": { "Секция данных". Говорит NASM'у: "Всё, что пойдет ниже,
;                    это наши переменные и константы, которые мы знаем заранее" }
; "section .text": { "Секция кода". Говорит: "А вот тут уже пошли настоящие команды
;                    для процессора, сам код" }
; "dd": { "Define Doubleword".
;         Двойное слово = 32 бита = 4 байта. По сути, команда "выдели мне
;         память под 4-байтное целое число" }
; "equ": { "Equate". Расшифровка: "приравнять". Создает константу. Это не переменная
;          в памяти, а просто замена текста. Везде, где я напишу 'N', NASM
;          перед сборкой подставит туда '7'. Удобно, чтобы не писать магические числа }
;
; --- Регистры (сверхбыстрая память прямо в процессоре) ---
; "rcx": { "Counter Register", 64 бита. Его традиционно используют как СЧЕТЧИК
;          в циклах }
; "rsi": { "Source Index", 64 бита. Обычно используется как УКАЗАТЕЛЬ на ИСТОЧНИК
;          данных. Мы его используем, чтобы "бегать" по массиву x }
; "rdi": { "Destination Index", 64 бита. УКАЗАТЕЛЬ на ПРИЕМНИК. Мы им "бегаем"
;          по массиву y. У меня в macOS он еще используется для передачи аргументов
;          в системные вызовы (например, код завершения) }
; "rbx": { "Base Register", 64 бита. Просто регистр общего назначения. Мы его
;          выбрали на роль переменной суммы }
; "rax": { "Accumulator", 64 бита. "Накопитель". Самый главный рабочий регистр
;          Используется в большинстве арифметических операций (особенно в делении)
;          и для хранения результата. В него же кладется номер системного вызова }
; "eax": { Это не отдельный регистр, а просто младшие 32 бита от 64-битного 'rax'
;          Используем его, потому что наши числа в массиве как раз 32-битные}
; "rdx": { "Data Register", 64 бита. "Регистр данных".
;          Сам по себе он ничего не может, но 'idiv' без него не работает }
;
; --- Инструкции (команды, которые понимает процессор) ---
; "mov": { "Move" (переместить). Главная команда. Копирует значение справа налево
;          Например, `mov rax, 10` -> положить 10 в rax }
; "xor": { "eXclusive OR" исключающее ИЛИ }
; "sub": { "Subtract" (вычесть). `sub rax, rbx` -> rax = rax - rbx }
; "add": { "Add" (сложить) `add rax, rbx` -> rax = rax + rbx }
; "movsx": { "Move with Sign eXtension" (переместить с расширением знака)
;           Она берет маленькое знаковое число (32 бита) и
;           делает из него большое (64 бита), сохраняя знак
;           Без нее -7 превратилось бы в огромное положительное число }
; "dec": { "Decrement" (уменьшить на 1). `dec rcx` -> rcx = rcx - 1 }
; "jnz": { "Jump if Not Zero" (прыгнуть, если не ноль). Если результат последней
;          операции был НЕ ноль, то переходим к указанной метке }
; "cqo": { "Convert Quadword to Octoword".
;          Она смотрит на знак в `rax` и растягивает его на весь `rdx`.
;          Нужна, чтобы `idiv` правильно работал с отрицательными числами }
; "idiv": { "Integer Division" (целочисленное деление со знаком). Делит пару
;           регистров `rdx:rax` на указанный регистр. Результат кладет в `rax` }
; "syscall": { "System Call" (системный вызов). Главная команда для общения с ОС
;              "Эй, ядро, сделай то, что я попросил в регистрах rax и rdi!" }
;
; --- Символы ---
; "[]": { Квадратные скобки. Означают: "не бери сам адрес, а загляни ВНУТРЬ
;         памяти по этому адресу и возьми значение оттуда". `mov eax, [rsi]` -
;         положить в `eax` не `rsi`, а то, на что `rsi` указывает }

section .data
    x   dd  5, 3, 2, 6, 1, 7, 4
    y   dd  0, 10, 1, 9, 2, 8, 5
    N   equ 7

section .text

global _start

_start:

    xor rbx, rbx          ; Обнуляем нашу переменную суммы

    mov rcx, N            ; Заряжаем счетчик. rcx теперь равен 7
                          ; Он будет тикать вниз, пока не дойдет до нуля

    mov rsi, x            ; В rsi кладем АДРЕС начала массива x
                          ; rsi теперь как закладка, которая указывает на пятерку
    mov rdi, y            ; То же самое для массива y. rdi указывает на ноль



calc_loop:
    ; Берем по одному числу из каждого массива
    mov eax, [rsi]        ; Взять число, на которое указывает rsi, и положить в eax

    sub eax, [rdi]        ; Вычесть из eax число, на которое указывает rdi
                          ; Теперь в eax лежит разница (x[i] - y[i])

    ; Добавляем разницу к общей сумме.
    movsx rdx, eax        ; Вот она, магия. eax (32 бита) может быть отрицательным
                          ; Чтобы добавить его к 64-битному rbx, нужно его "растянуть"
                          ; до 64 бит, сохранив знак. movsx это и делает

    add rbx, rdx          ; Кидаем результат в нашу общую копилку rbx

    ; Двигаем наши "закладки" на следующие числа в массивах
    add rsi, 4            ; Числа у нас по 4 байта (dd), так что двигаем на 4
    add rdi, 4            ; То же самое для второго массива

    ; Проверяем, не пора ли заканчивать цикл
    dec rcx               ; Уменьшаем счетчик на 1
    jnz calc_loop         ; Если rcx еще НЕ ноль, прыгаем обратно на метку calc_loop
                          ; Если уже ноль, то выходим из цикла и идем дальше

    ; Теперь надо поделить ее на N (7).

    ; Деление в ассемблере - это целый ритуал.
    mov rax, rbx          ; Команда idiv делит пару rdx:rax. Так что кладем нашу сумму в rax
    cqo                   ; Еще одна команда-ритуал. Она "растягивает" знак из rax
                          ; на весь rdx. Если rax отрицательный, rdx станет -1
                          ; Теперь пара rdx:rax готова к делению
    mov rcx, N            ; В rcx кладем то, НА что будем делить (наш делитель 7)
    idiv rcx              ; Делим rdx:rax на rcx. Результат (частное) сам падает в rax
                          ; В rax теперь лежит наш ответ (-1)


    mov rdi, rax          ; В macOS код завершения программы передается через rdi.
                          ; Кладем туда наш результат.
    mov rax, 60
    syscall